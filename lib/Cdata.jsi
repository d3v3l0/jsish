#!/usr/bin/env jsish

require('Jsish');

// A C-API generator for structs, enums, maps, and extensions.

function Cdata(args:array, conf:object=void)
{
    
    var options = {         // The C-API preprocessor for structs and enums.
        cc          :'gcc', // Compiler to use with -compile.
        compile       :false,// Compile shared lib directly from .jsc arg: uses -cflags
        confSuffix  :'',    // Suffix to add to struct used for object config.
        cflags      :false, // Return CFLAGS to compile FILE/FILE.so from .c generated by a .jsc.
        eval        :false, // Evaluate in interp.
        json        :false, // Output json definitions.
        jsc         :'',    // String to use for .jsc input.
        memDebug    :false, // Enable memdebug
        name        :null,  // Name of group
        noline      :false, // Do not add #line to c output file
        O           :'',    // Output file, or '-' to return string. Default is FILE.c.
        unkType     :true,  // Warn of unknown struct fields self will be ignored.
        varSuffix   :'_Data'// Suffix to add to data used for object config.
    };

    var self = {
        pre:'', pre0:'', pre1:'', out0:'', out1:'', out:'', iout:'',
        init:[], types:'',  structs:'', enums:'', vars:'', cmds:'',
        varnames:[], mapnames:[], cmdnames:[], 
        structmap:{}, enummap:{}, enumzero:{}, structfieldmap:{},
        vardefs:'',  siglst:[], varinits:'', mapinits:'', enumIni:{},
        portlst:[], statlst:[], cmddefs:'', cmddef:'',
        enumvals:{}, indata:'', infile:'', outFile:null, rootname:null,
        lnstart:0, setCons:0, icode:[], outcode:'', addflags:'',
        preface: '// DO NOT EDIT: file generated by ',
        Trace       :false, jscHeaderStr:'', parmFlags:'',
        objOptCmdStr:'', objCmdStr:'', selfSuffix:'',
    };
    self.pkg = require('Cdata', 0);
    self.version = self.pkg.version;
    self.verStr = self.pkg.verStr;
    var Ex = {asize:0, offs:1, size:2, sig:3};
    var EV = { enum:[], struct:[], vars:[] };

    moduleOpts(self, options, conf);
    Object.freeze(self, true, true);

    var defs = {structs:[], enums:[], types:[], vars:[], cmds:[]};
    //var popts = { hassig:true, hassiz:false, builtinhassig:true};


    var typeNameStr = "number string boolean array function object regexp any userobj void null undefined";
    var typeNameList = typeNameStr.split(' ');
    
    var portTypes = 'BOOL,UINT8,UINT16,UINT32,UINT64,INT8,INT16,INT32,INT64,DOUBLE,LDOUBLE,TIME_W,TIME_D,STRBUF';
    var statTypes = 'TIME_T,INT,UINT,LONG,ULONG,SHORT,USHORT,INTPTR,UINTPTR,SIZE_T,'+portTypes;
    var valpTypes = 'STRING,VALUE,VAR,FUNC,ARRAY,OBJ,REGEX,USEROBJ';
    var portableTypes = portTypes.split(',');
    var staticTypes = statTypes.split(',');
    var valuePTypes = valpTypes.split(',');
    
    function GetBaseType(styp) { //TODO: lookup with info type.
        switch (styp) {
            case 'bool':     return 'BOOL';  case 'uint':     return 'UINT'; 
            case 'int':      return 'INT';   case 'double':   return 'DOUBLE';  
            case 'int8_t':   return 'INT8';  case 'int16_t':  return 'INT16';
            case 'int32_t':  return 'INT32'; case 'int64_t':  return 'INT64';   
            case 'uint8_t':  return 'UINT8'; case 'uint16_t': return 'UINT16';
            case 'uint32_t': return 'UINT32';case 'uint64_t': return 'UINT64';  
            case 'ulong':    return 'ULONG'; case 'long':     return 'LONG';
            case 'ushort':   return 'USHORT';case 'short':    return 'SHORT';     
            case 'double':   return 'DOUBLE';case 'ldouble':  return 'LDOUBLE';
            case 'size_t':   return 'SIZE_T';case 'Jsi_Number':return 'NUMBER';
            case 'Jsi_Wide': return 'INT64'; case 'Jsi_UWide': return 'UINT64';
            case 'Jsi_Sig':  return 'UINT32';
            case 'intptr_t': return 'INTPTR';case 'uintptr_t':return 'UINTPTR';  
            case 'time_w':   return 'TIME_W';case 'time_d':   return 'TIME_D';  
            case 'time_t':   return 'TIME_T';
            case 'const char*':return 'STRKEY';  case 'Jsi_Strkey':return 'STRKEY';  
            case 'Jsi_DString': return 'DSTRING';
            default:
                if (styp.substr(0,6) === 'STRING') {
                    var num = parseInt(styp.substr(6));
                    if (isNaN(num) || num<=0) return null;
                    return 'STRBUF';
                     
                }
        }
        return null;
    }
    
    function CompileShared(fn:string) {
        var fne = File.extension(fn), fnr=File.rootname(fn), name=fnr, fnc = fnr;
        var out = fnr+'.so';
        if (fne != '.c')
            throw('expected a .c file: '+fn);
        if (fn.indexOf('/')>=0)
            throw('file may not have path: '+fn);
        puts('Compile generated file', fn, 'to', out);
        var flags = GetCflags([out]);
        var cmd = self.cc + ' ' + flags + ' '+self.addflags;
        puts(cmd);
        try {
            exec(cmd);
        } catch (e) {
            puts('Error:', e);
        }
//        puts(exec(self.cc + ' `'+Info.executable()+' -c -cflags true '+fnr+'.so`'));
    }
    
    function GetCflags(args:array) {
        var fn = args[0], fne = File.extension(fn), fnr=File.rootname(fn), name=fnr, fnc = fnr;
        if (fn.indexOf('/')>=0)
            throw('file may not have path: '+fn);
        switch (fne) {
            case '.so': fnr += '.so';
            case '.c':
            case '': fnc += '.c'; break;
            default: throw('extension not one of: .so .c ""');
        }
        if (!File.readable(fnc) && File.readable(name+'.c'))
            fnc = name+'.c';
        if (!File.readable(fnc))
            LogWarn('file not found: '+fnc);
        var s = '-g -Og -O0 -Wall -fPIC -DJSI__SQLITE=1'
            + ' -DJSI__READLINE=1 -fno-diagnostics-show-caret -Wc++-compat'
            + ' -Wwrite-strings -DJSI_CDATA_MAIN=1 -x c -rdynamic';
        if (args.length<=1 && self.memDebug)
            s += ' -DJSI__MEMDEBUG=1';

        var libDir = Interp.conf('pkgDirs')[0];
        var pDir = File.dirname(libDir), srcDir = pDir + '/src';
        if (!File.readable('jsi.c') && !File.readable(srcDir+'/jsi.c'))
            LogWarn('can not locate jsi.c');
        var wDir = pDir + '/websocket';
        s += ' -I'+srcDir;
        var isWS = File.readable(wDir+'/build/unix/libwebsockets.a');
        if (isWS)
            s += format(' -DJSI__WEBSOCKET=1 -I%s/src/lib  -I%s/src/build -I%s/unix -I%s/build/unix ', wDir, wDir, wDir, wDir);
        s += ' -o '+fnr+' '+fnc;
        if (args.length>1) {
            s += ' -DCDATA_MULTI_INC=1 -DCDATA_JSI_C_MAIN_'+name;
            var aalst = [], arst = args.slice(1);
            for (var al of arst) {
                if (File.extension(al) == '.c')
                    aalst.push(File.rootname(al));
            }
            var pnl = name;
            for (al of aalst) {
                s += ' -DCDATA_MODINIT_CHAIN_'+pnl+'=Jsi_Init'+al;
                pnl = al;
            }
            s += ' '+arst.join(' ');
            if (aalst.length && fne == '.so')
                throw("can not add .c files to a .so build");
        }
        s += ' -lm';
        if (fne === '.so')
            s += ' -shared -DJSI_CDATA_SHARED=1';
        if (isWS)
            s += ' -L '+wDir+'/build/unix/ -lwebsockets';
         var sDir = pDir + '/sqlite';
        var isSQ = File.isdir(sDir);
        if (isSQ)
            s += ' -I'+sDir+'/src -L '+sDir+'/build/unix/ -lsqlite3';

        s += ' -lm -ldl -lpthread';
        if (!isSQ)
            s += ' -lsqlite3';
        return s;
    }
    
    function typeValidate(prefix, typ) {
        var tlst = typ.split('|');
        var i = -1;
        for (i = 0; i<tlst.length; i++)
            if (typeNameList.indexOf(tlst[i]) < 0)
                throw prefix+ " type unknown '"+tlst[i]+'" not one of: '+typeNameStr;
        return tlst;
    }
    
    function CountNL(str:string) {
        return str.split('\n').length;
    }
    
    function HashLine(lnum:number, str:string='') {
        if (self.noline)
            return '';
        var olnum = lnum;
        if (str !== '') {
            var sstr = str.substr(0, 100);
            var d = self.indata, l1 = d.indexOf(sstr), l2 = d.lastIndexOf(sstr);
            if (l1>=0 && l1===l2) {
                lnum = CountNL(d.substr(0, l1));
                if (lnum != olnum) {
                    LogTrace('ADJ: ', lnum, ' != ', olnum);
                }
            }
        };
        return '#line '+lnum+' "'+self.infile+'" /* jsi_CData.jsi */\n';
    }

    function GenType(def) {
        // TODO
        //self.types += "  { \""+name+"\", \""+label+"\", 0, sizeof(name), \""+fmt+"\", "+cformat+", },\n";
    };
    
    // Define an enum
    function GenEnum(def) {
        // TODO: generate lookup string table. Also enhance Jsi_Opt_SwitchEnum to support more than just 0,1,2...
        LogTrace("def=",def);
        var flags = 0;
        with (def) {
            self.portlst.push(name);
            self.statlst.push(name);
            if (label)
                self.pre0 += "/* "+label+" */\n";
            var flnhash = HashLine(lnum);
            self.pre0 += flnhash+"typedef enum "+name+" {\n";
            //self.pre += "  ";
            var eName = name+"_Enum"; "jsi_csitems_"+name;
            var evDef = {name:name}, evItems = [];
            self.enummap[name] = eName;
            self.enums += "    {.sig=JSI_SIG_OPTS_ENUM, .id=JSI_OPTION_CUSTOM, .name=\""+name+"\""
                +", .offset="+flds.length+", .size=sizeof(enum "+name+"), .init={}"
                + ", .help=\""+(label?label:'')+"\""
                + ", .flags="+ flags+", .custom=0"
                + ", .data=(void*)"+eName
                +", .info=0, .tname=\"\""
                +", .value=0"
                +", .bits=0, .boffset=0, .idx=0, .ssig=0, .crc=0"
                +", .userData=0, .extData=(uchar*)"+ eName+"},\n";
            self.iout += "  static Jsi_EnumSpec "+eName+"[] = {\n";
            var strKeys = "";
            for (var i in flds) {
                var f = flds[i];
                var nname = f.name;
                self.enumvals[nname] = f.value;
                var evIt = {name:nname, value:f.value};
                if (f.label)
                    evIt.help = f.label;
                if (f.flags)
                    evIt.flags = f.flags;
                if (f.value === 0)
                    self.enumzero[name] = 1;
                f.value = format('0x%x', f.value);
                self.iout += "    {.sig=JSI_SIG_OPTS_FIELD,  .id=JSI_OPTION_CUSTOM, .name=\""+nname+"\", .offset=0, .size=0"
                +", .init={}, .help=\""+(f.label?f.label:'')+"\""
                +", .flags="+ flags+", .custom=0, .data=0, .info=0, .tname=0, .value="+f.value+"},\n";
                self.pre0 += "  "+nname+"="+f.value+",\n";
                if (strKeys !== '')
                    strKeys += ",";
                strKeys += "\""+nname+"\"";
                evItems.push(evIt);
            }
            strKeys += ", 0";
            var skname = eName+"_Strkeys"; //"jsi_csstrKeys_"+name;
            self.pre1 += "\n  const char *"+skname+"[] = { "+strKeys+", 0};\n";
            self.iout += "    {.sig=JSI_SIG_OPTS_FIELD,  .id=JSI_OPTION_END, .name=\""+name+"\", .offset=0, .size="+flds.length
                + ", .init={.STRKEY="+skname+"}}\n  };\n\n";
            self.pre0 += "} "+name+";\n\n";
            EV.enum.push([evDef, evItems]);
        }
    }
    
    // Define a struct
    function GenStruct(def) {
        var sc = '', fieldstr = '', name = def.name, definit = def.init, sig = 0, cnt = 0, aspre = '', lnum=def.lnum;
        var hassig = false;
        if (!def.Array)
            def.Array = 0;
        var evDef = {name:name}, evItems = [];
         if (def.label) {
            sc += "/* "+def.label+" */\n";
            evDef.help = def.label;
        } else {
            def.label = '';
        }
        var flnhash = HashLine(lnum);
        sc += flnhash+"typedef struct "+name+" {\n";
        var bsgets=[], bscnt = 0, inits = [], hasinit = 0, fcnt = 0, flags = 0, bsget = 0,
            crc = 0, scrc = '', port=1, stat=1, portconds='';
        // self.out( [subst -novariables fields]
        for (var ii in def.flds) {
            var f = def.flds[ii];
            if (!f)
                continue;
            LogTrace("f:",f);
            var type = f.id, fname = f.name, ofname = fname, fflags = f.flags,
                st = GetBaseType(type), isval = (st == null && valuePTypes.indexOf(type)>=0),
                evIt = {name:fname, type:f.id}, rotype=type, isunder = (fname.substr(0,1)=='_' || fname=="interp");
            if (isval)
                rotype = 'Jsi_Value*';
            //if (fflags)
            //    evIt.flags=fflags;
            if (f.label)
                evIt.help = f.label;
            //if (f.flags)
            //    evIt.flags = f.flags;
            if (type == 'Jsi_Sig')
                st = 'UINT32';
            if (scrc === '')
                scrc += ',';
            scrc += rotype;
            var des = '',
                fdescr = (f.label?f.label:'');
            if (!cnt++ && fname == 'sig') {
                fflags += '|JSI_OPT_FMT_HEX';
                if (!f.bit && !f.asize) {
                    hassig = true; sig = f.init;
                }
            }
            if (fdescr)
                 des = "  /* "+fdescr+" */ ";
            var asiz = 0, option=0, bitsiz = 0, bsiz = 0, offset;
            var s, bn, bsizstr = '';
            if (f.bit) {
                evIt.bits = f.bit;
                scrc += ':'+f.bit;
                offset = 0;
                bsget = "jsi_cs_bsget_"+name;
                option = bscnt++;
                bitsiz = f.bit;
                bsgets.push([f.name, type+" "+f.name+":"+bitsiz,type, f.idx]);
                bsiz = Math.floor((f.bit+7)/8);
                bsizstr = ':'+f.bit;
            } else {
                offset = "Jsi_Offset("+name+","+fname+")";
                bsiz = "sizeof("+rotype+")";
                bitsiz = "8*"+bsiz;
                if (stat) {
                    if ((!st || staticTypes.indexOf(st)<0) && self.statlst.indexOf(type)<0)
                        stat = 0;
                }
                if (!stat)
                    port =0;
                else if (port) {
                    if ((!st || portableTypes.indexOf(st)<0) && self.portlst.indexOf(type)<0)
                        port = 0;
                }
            }
            /*if (!f.bit && !f.asize && st != null) {
                fieldstr += '    JSI_OPT('+st+", "+name+", "+fname+", .help=\""+fdescr+"\", .flags="+fflags+" ),\n";
                continue;
            }*/
            if (f.asize) {
                bsizstr = '['+f.asize+']';
                scrc += bsizstr;
            }
            var sinit = 0, csinit = 0;
            if (self.enumIni[type] !== undefined)
                sinit = self.enumIni[type];
            else if (type === 'pthread_mutex_t')
                sinit = 'PTHREAD_MUTEX_INITIALIZER';
            else if (f.isstr || type.match(/^STRING[0-9]+$/)) {
                if (f.init === undefined)
                    sinit = "{}";
                else
                    sinit = "\""+f.init+"\"";
            } else if (f.asize) {
                sinit = "{}";
            } else if (f.init !== undefined) {
                sinit = f.init;
            } else if (self.structmap[type]) {
                sinit = "JSI_INI_DEFN_"+type;
                if (fname.match(/Opts$/))
                    self.structfieldmap[name+'.'+type] = fname;
            }
            var otype = st;
            
            var issubopt = (self.structmap[type] !== undefined);
            var isenum = (self.enummap[type] !== undefined);
            if (isenum && !self.enumzero[type])
                LogWarn(name, '.', fname, ': enum ', type, "does not define a zero value");
            var bdata = 0;
            var rest = ', .custom=0, .data=' + (f.data? ('(void*)"'+f.data+'"'):'0');
            if (isunder) {
            } else if (isval) {
                otype = type;
                st = 'Jsi_Value*';
                
            } else if (!st && !isval) {
                otype = st = 'CUSTOM';
                if (issubopt) {
                    LogTrace("SUB:", type);
                    rest = ', .custom=Jsi_Opt_SwitchSuboption, .data=(void*)'+self.structmap[type];
                } else if (isenum) {
                    rest = ', .custom=Jsi_Opt_Switch'+(f.bitset?'Bitset':'Enum')+', .data=(void*)'+self.enummap[type];
                    fflags += '|JSI_OPT_ENUM_SPEC';
                } else {
                    if (f.asize)
                        throw("array of unspecified unsupported: "+name+'.'+fname);
                    rest = ', .custom=Jsi_Opt_SwitchNull, .data=0';
                    if (self.unkType && !f.nowarn && type !== "Jsi_Interp*" && type !== "void*") {
                        var tvlen = type.length;
                        if (type[tvlen-1] !== '*' || type[tvlen-2] !== '_' || !self.structmap[type.substr(0,tvlen-2)])
                            puts('ignoring unknown type "'+type+'": ' +name+'.'+fname);
                    }
                }
            }
            if (isunder) {
            } else if (f.asize) {
                evIt.size = f.asize;
                if (f.bit)
                    throw("array of bits unsupported: "+name+'.'+fname);
                if (isenum)
                    throw("array of enums unsupported: "+name+'.'+fname);
                if (self.structmap[type]) {
                    csinit = "(uchar*)&jsi_csini_data_"+type;
                    var fasize = parseInt(f.asize);
                    if (fasize && sinit == "{}") {
                        var aill = [];
                        for (var ailn = 0;  ailn<fasize; ailn++)
                            aill.push("JSI_INI_DEFN_"+type);
                        sinit = '{'+aill.join(',')+'}';
                    }
                }
                //if (issubopt)
                    //throw("array of structs unsupported: "+name+'.'+fname);
                var arnam = name+'_'+fname+'_Specs';
                aspre += '\n  static Jsi_OptionSpec '+arnam+'[] = {\n'
                    + '    JSI_OPT_CARRAY_ITEM_(JSI_SIG_OPTS_FIELD,'+otype+', '+name+', '+fname+', .help="'+fdescr+'", .flags='+fflags+rest+'),\n'
                    + '    JSI_OPT_END_(JSI_SIG_OPTS_FIELD,'+name+', .help="Options for array field '+name+'.'+fname+'")\n  };\n\n';
                fieldstr += '    JSI_OPT_CARRAY_(JSI_SIG_OPTS_FIELD,'+name+', '+fname+', "'+fdescr+'", '+fflags+', '+arnam+', '+f.asize+', "'+type+'", '+csinit+'),\n';
            } else if (f.bit) {
                if (isenum)
                    bdata = '&'+self.enummap[type];
                fieldstr += '    JSI_OPT_BITS_(JSI_SIG_OPTS_FIELD, '+type+', '+fname+', "'+fdescr+'", '+fflags+', '+bsget+', '+f.idx+', "'+type+'", '+bdata+'),\n';
            } else {
                fieldstr += "    JSI_OPT_(JSI_SIG_OPTS_FIELD, "+otype+", "+name+", "+fname+", .help=\""+fdescr+"\", .flags="+fflags+rest
                    +", .info=0, .tname=\""+type+"\""+", .value=0, .bits="+option+",.boffset="+bitsiz+" ),\n";
            }
            sc += "  "+rotype+" "+ofname+bsizstr+";"+des+"\n";
            inits.push(sinit);
            evItems.push(evIt);
        }
        if (name == self.name)
            sc += '  Jsi_PkgOpts* popts;\n';
        crc = 0;
        if (!port) // Non-portable fields add platform crc.
            crc = Info.platform().crc;
        else
            self.portlst.push(name);
        if (stat)
            self.statlst.push(name);
        crc = Util.crc32(scrc, crc);
        if (!crc) // Take care of corner case where crc is 0.
            crc = Util.crc32(scrc+'.');
        crc = format("%#x", crc);
        if (!sig && hassig) {
            sig = crc;
            inits = inits.slice(1);
            inits.unshift(crc);
        }
        
        definit = inits.join(',');
        sc += "} "+name+";\n\n";
        var init = '0';
        if (def.init && def.init !== "{}") {
            init="(void*)&jsi_csini_data_"+name;
            self.iout += "\n#define JSI_INI_DEFN_"+name+" {"+definit+"}\n";
            self.iout += "  static "+name+" jsi_csini_data_"+name+" = JSI_INI_DEFN_"+name+";\n";
            self.init[name] = init;
        } else
            definit=0;
        self.pre0 += sc;
        //self.pre1 += aspre;
        if (bsgets.length) {
            var rc = "\n/* A set/get bitfield function for the struct \"name\". */\n"
                + "static Jsi_RC jsi_cs_bsget_"+name+"(Jsi_Interp *interp, void *data, Jsi_Wide *s, Jsi_OptionSpec *spec, int idx, bool isSet) {\n"
                + "  int same;\n  const char *fname=\"\";\n"
                + "  struct "+name+" *p = (struct "+name+" *)data;\n"
                + "  switch (idx) {\n";
            for (var k in bsgets) {
                var i = bsgets[k][0];
                var j = bsgets[k][1];
                var btyp = bsgets[k][2];
                var bidx = bsgets[k][3];
                var tvar = (btyp.substr(0,1) == 'u'?'Jsi_UWide':'Jsi_Wide');
                var rr =  "      "+tvar+"* t = ("+tvar+"*)s;\n"
                    + "      if (!isSet) {*t = p->"+i+"; return JSI_OK; }\n"
                    + "      p->"+i+"= ("+btyp+")*t;\n"
                    + "      "+btyp+" oldv = ("+btyp+")*t;\n"
                    + "      if (!(same = (p->"+i+" == ("+btyp+")*t))) {\n"
                    + "          p->"+i+" = oldv;\n"
                    + "          fname = \""+j+"\";\n"
                    + "      }\n"
                    + "      break;\n";
                rc += "\n    case "+bidx+": {\n"+rr+"    }\n";
            }
            rc += "\n    default: {Jsi_LogWarn(\"bad index: %d\",idx); return JSI_ERROR; }\n";
            rc += "  }\n"
                    + "  if (!same) { Jsi_LogWarn(\"value %\" PRId64 \" out of range for field '%s'\",*s, fname); return JSI_ERROR; }\n"
                + "  return JSI_OK;\n}\n\n";
            self.out += rc;
        }

        var specname = name+'_Specs';
        self.pre0 += '#define '+name+'_Sig '+sig+'\n\n';
        self.iout += aspre + "\n  static Jsi_StructSpec "+specname+"[] = {\n"+ fieldstr
            +"    JSI_OPT_END_(JSI_SIG_OPTS_STRUCT, "+name+', .help="'+def.label+'")\n  };\n\n';
        self.structs += "    {.sig=JSI_SIG_OPTS_STRUCT, .id=JSI_OPTION_CUSTOM, .name=\""+name+"\""
            +", .offset="+def.flds.length
            +", .size=sizeof("+name+")"
            +", .init={.CUSTOM=(void*)"+bsget+"}"
            +", .help=\""+def.label+"\""
            +", .flags="+(def.flags?def.flags:0)
            +", .custom=(Jsi_OptionCustom*)"+init
            +", .data=(void*)"+specname
            +", .info=0"
            +", .tname="+def.Array
            +", .value=0"
            +", .bits=0, .boffset=0, .idx="+0+", .ssig="+sig+", .crc="+crc
            +", .arrSize=0, .userData=0, .extData=(uchar*)"+ specname+"},\n";
            EV.struct.push([evDef, evItems]);
    }

    // Generate Vars.
    function GenVars(def) {
        var sc = '', fldini = '', name = def.name, definit = def.init;
        if (!def.Array)
            def.Array = 0;
        if (def.label)
            sc += "/* "+def.label+" */\n";
        else
            def.label = '';
        var fcnt = 0;
        for (var ii in def.flds) {
            var f = def.flds[ii];
            if (!f)
                continue;
            LogTrace("f:",f);
            var fieldstr = '', type = f.type, fname = f.name, ofname = fname, fflags = 0, parms = '';
            var evDef = f.name, evItems = {structName:type };
            var anum = f.asize;
            if (f.ismap) {
                evItems.mapType = 'tree';
                if (anum) {
                    if (anum.substr(0,1) === '#') {
                        evItems.mapType = 'hash';
                        anum = anum.substr(1);
                        parms = "#";
                    }
                    if (anum.substr(0,1) === '@') {
                        anum = anum.substr(1);
                        evItems.keyName = anum;
                    }
                    if (anum === '0') {
                        evItems.keyType = 'num';
                    } else if (anum.length) {
                        if (!self.structmap[anum])
                            throw("map index struct unknown: "+anum);
                    }
                }
            } else {
                if (anum) {
                    if (typeof(anum) !== 'number') {
                        if (typeof(anum) === 'string' && self.enumvals[anum] !== undefined) {
                            f.asize = self.enumvals[anum];
                        } else if (isNaN(f.asize = new Number(anum)))
                            throw("not a number: "+anum+' ' +typeof(anum));
                    }
                }
                if (f.asize)
                    evItems.arrSize = f.asize;

            }
            //evItems.varParam = parms;

            var sv, des = '',
                fdescr = (f.label?f.label:'');
            if (fdescr)
                 des = "  /* "+fdescr+" */ ";
            LogTrace("type:", type);
            fieldstr = type+" " + fname;
            if (f.asize && !f.ismap) {
                fieldstr += "[" + f.asize + "]";
            }
            var rest = '';
            if (self.structmap[type]) {
                rest = ', .spec='+self.structmap[type];
                LogTrace("KTYPE: "+f.ktype);
                if (f.ktype && self.structmap[f.ktype])
                    rest += ', .keySpec='+self.structmap[f.ktype];
                
            }
            if (f.ismap) {
                sv = '    {.sig=JSI_SIG_OPTS_VARDEF, .id=JSI_OPTION_CUSTOM, .name="'+fname+'"'
                    +", .offset=0, .size=0, .init={}"
                    +', .help="'+fdescr+'"'
                    +', .flags='+fflags
                    +', .custom=0'
                    +', .data=(void*)&'+fname
                    +', .info="'+type+'"'
                    +', .tname="'+f.ktype+'"'
                    +', .value=0, .bits=0, .boffset=0,.idx=0,.ssig=0,.crc=0'
                    +', .arrSize=0, .userData="'+f.varParam+'"'
                    + '},\n';

                self.vardefs += sv;
                self.pre += 'extern Jsi_Map *'+fname+";\n";
                self.out0 += 'Jsi_Map *'+fname+";\n";
            } else {
                sv = '    {.sig=JSI_SIG_OPTS_VARDEF, .id=JSI_OPTION_CUSTOM, .name="'+fname+'"'
                    +", .offset=0, .size=0, .init={}"
                    +', .help="'+fdescr+'"'
                    +', .flags='+fflags
                    +', .custom=0'
                    +', .data=(void*)&'+fname
                    +', .info="'+type+'"'
                    +', .tname="'+f.ktype+'"'
                    +', .value=0, .bits=0, .boffset=0,.idx=0,.ssig=0,.crc=0'
                    +', .arrSize='+f.asize+', .userData="'+f.varParam+'"'
                    + '},\n';

                self.vardefs += sv;
                self.pre += 'extern '+fieldstr+";\n";
                self.out0 += fieldstr+";\n";
            }
            EV.vars.push([evDef, evItems]);
        }
    }

    // Define a command extern/extension
    function GenCmd(def) {
        LogTrace("def=",def);
        var hasconstr = 0, hastilde = 0;
        var ind='  ', sc = '', fldini = '', name = def.name, definit = def.init, lnum = def.lnum;
        var reg = /^function\s*(~|[a-zA-Z0-9_]*)\s*\(([^)]*)\)(:[\|a-z]+|)\s*\{(.*)$/;
        var rega = /^([a-zA-Z0-9_]+)(:[|a-z]+|)(=.+|)$/;
        var keys = Info.keywords();
        var fnames = def.fnames;
        var isObj = (fnames.indexOf(name)>=0);
        var intData = (!isObj && self.varnames.indexOf(name+self.varSuffix)<0);
        if (name !== self.name)
            LogWarn('Note: coercing extension name "'+name+'" to match file "'+self.name+'"');
        name = self.name;
        keys.push('length', 'constructor','prototype');
        if (def.label)
            sc += "/* "+def.label+" */\n";
        else
            def.label = '';
        self.icode[name+'_'] = '';
        self.icode[name+'~'] = '';
        var fcnt = 0;
        var otyp = name+self.confSuffix;
        var ifpre = def.preface, ipre = '', ffpre = '\nstatic Jsi_CmdSpec '+name+'Cmds[] = {\n';
        if (self.structmap[name+'_']) {
            if (self.varnames.indexOf(name+'_Data')>=0)
                self.out += '\n#define CDATA_CODE_GLOB_VAR_'+name+' 1\n';
            else
                self.out += '\n#define CDATA_CODE_PER_INTERP_'+name+' 1\n';
            self.out += '\nstatic const char* '+name+'_PkgInfo = NULL;\n';
        }
        // Process functions
        for (var ff of def.flds) {
            var f = ff[0];
            var flnof = ff[1];
            LogTrace("ff=",ff);
            var fre = reg.exec(f.trim());
            if (!fre)
                throw "invalid function: "+f;
            var fflags = 0, finfo = 0, fopts = 0, fretType = 0;
            var fbody = fre[4];
            var fhelp = ''; // TODO: pull out of comment.
            var fhnl = fbody.indexOf('\n');
            var fhcm = fbody.indexOf('//');
            if (fhnl>0 && fhcm>=0 && fhcm<fhnl)
                fhelp = fbody.substr(fhcm+2, fhnl-3);//.trim();
            var fname = fre[1];
            var fconstr = (fname === name);
            if (fconstr)
                hasconstr = 1;
            var isinitdel = (fname === '_' || fname === '~');
            var flnhash = HashLine(lnum, fbody);
            if (isinitdel) {
                if (fname === '~')
                    hastilde = 1;
                if (fre[3] || fre[2])  throw('function '+fname+' may not have args or return type');
                //var fff = (fname==='_'?'INIT_DONE':'OBJ_FREE');
                //self.out += '\n#define CDATA_CODE_'+fff+'_'+name+' {\\\n'+fbody.trim().map(['\n', '\\\n'])+'\n\n';
                self.icode[name+fname] = '{\n'+flnhash+fbody+'\n';
                continue;
            }
            if (keys.indexOf(fname)>=0)
                throw("function name can not be a keyword: "+fname);
            if (!fre[3] || fre[3] == ':')
                throw "must specify a return type for function: "+fname;
            var ifpost = '', ifpostarg = '', ifprecc2;
            var isObjNew = (isObj && fconstr);
            var fcmdName = name+fname+'Cmd', fcmdName2 = fcmdName;
            ifpre += '\n// function '+fre[1]+'('+fre[2]+')'+fre[3];
            if (isObjNew) {
                ifprecc2 = ', '+otyp+' *cmdPtr';
            } else {
                ifprecc2 = ',  Jsi_PkgOpts *vrPtr';
                fcmdName2 += 'Sub';
            }
            var fcprefix = '(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr';
            ifpre += '\nstatic Jsi_RC '+fcmdName2 + fcprefix + ifprecc2 + ') {\n';
            var svendx = 'Jsi_LogTraceExt("'+name+fname+'");\n';
            if (isObj && !fconstr) {
                if (!self.setCons)
                    self.out += '#define CDATA_CONSTRUCTOR 1\n';
                self.setCons=1;
                ifpre += '  '+otyp+' *cmdPtr = ('+otyp+' *)Jsi_UserObjGetData(interp, _this, funcPtr);\n'
                    + '  if (!cmdPtr) return Jsi_LogError("Apply in a non object"); \n'+svendx;
            } else if (intData) {
                ifpre += '#ifdef JSI_INI_DEFN_'+otyp+'\n  '+otyp+' *cmdPtr = ('+otyp+' *)Jsi_InterpGetData(interp, "'+name+'", NULL);\n'
                    + '  if (!cmdPtr) return Jsi_LogError("Missing interp data"); \n'+svendx+'#endif\n';
            }
            var rettyp = typeValidate('return', fre[3].substr(1));
            if (rettyp.length>1 || rettyp[0] != 'any') {
                var rtvl = [];
                for (var rti of rettyp) {
                    rtvl.push('JSI_TT_'+rti.toUpperCase());
                    
                }
                fflags = '(uint)('+rtvl.join('|')+')';
            }
            var args = fre[2].trim();
            var alst = (args===''?[]:args.split(','));

            var minargs = alst.length, maxargs = minargs;
            var last = alst.length-1;
            // Process parameters
            for (var i = 0; args !== '' && i<=last; i++) {
                var aval = alst[i].trim();
                if (aval === '...') {
                    if (i != last)
                        throw "expected ... to be at end";
                    maxargs = -1;
                    if (minargs === alst.length)
                        minargs = alst.length-1;
                    continue;
                }
                var avals = rega.exec(aval);
                if (!avals)
                    throw "invalid argument: "+aval;
 
                var afnam = avals[1];
                if (!avals[2])
                    throw("argument '"+aval+"' must have a type in function: "+fname);
                if (keys.indexOf(afnam)>=0)
                    throw("argument name can not be a keyword: "+fname);
                var atyp = avals[2].substr(1);
                var tvlst = typeValidate('argument', atyp);
                var iasfx = '', iat = '', tlen = tvlst.length, vget='', ttnam='';
                

                var dv = 0;
                if (avals[3] && avals[3] != '') { // Default value
                    if (minargs===alst.length)
                        minargs = i;
                    //ifpre += ind+'if (__argc <= '+i+') ';
                    var defval = avals[3].substr(1);
                    var dvlen = defval.length;
                    switch (defval) {
                        case 'true': dv = 1; iat='boolean'; break;
                        case 'false': dv = 0; iat='boolean'; break;
                        case 'void': dv=0; iat='void';  break;
                        case 'undefined': dv=0; iat='undefined'; break;
                        case 'null': iat='null'; break;
                        default:
                            if ((defval.substr(0,1) == "'" && defval.substr(dvlen-1,1) == "'")
                                || (defval.substr(0,1) == '"' && defval.substr(dvlen-1,1) == '"')) {
                                dv = '"'+defval.substr(1,dvlen-2)+'"';
                                iat='string';
                            } else {
                                dv = parseFloat(defval);
                                iat='number';
                                if (isNaN(dv))
                                    throw "Unrecognized default "+defval+" in function: "+fname;
                            }
                    }
                    if (iat !== '' && tvlst.indexOf(iat)<0) {
                        tvlst.push(iat);
                        tlen++;
                    }
                    iasfx = (tlen==1?'':'_'+iat);
                }
                else if (minargs!==alst.length)
                    throw "non-default value follows default: "+aval+' in function: '+fname;
                
                var voao = 'Jsi_ValueArrayIndex(interp, args, '+i+')';
                    
                if (tlen===1) {
                    iat = tvlst[0];
                    var iftn = 'Jsi_Value*', iftnpost = '';
                    iasfx = (tlen===1?'':'_'+iat);
                    switch (iat) {
                        case 'boolean': iftn = 'bool'; ttnam = 'Bool'; break;
                        case 'number': iftn = 'Jsi_Number'; ttnam = 'Number'; break;
                        case 'string': iftn = 'const char*'; iftnpost = ' int '+afnam+'Len = 0;';
                            if (tlen==1)
                                vget='if (Jsi_ValueGetLength(interp, args) > '+i+' && !('+afnam+'=Jsi_ValueString(interp, '+voao+', &'+afnam+'Len))) '
                                + '{ Jsi_LogError("expected string"); return JSI_ERROR; }\n';
                            break;
                    }
                    ifpre += ind+iftn + ' '+afnam+iasfx+' = '+dv+';\n' + iftnpost;
                    if (ttnam !== '' && vget === '')
                        vget='if (Jsi_ValueGetLength(interp, args) > '+i+' && Jsi_Get'+ttnam+'FromValue(interp, '+voao+', &'+afnam+') != JSI_OK) '
                        + '\n'+ind+'  { Jsi_LogError("expected '+atyp+'"); return JSI_ERROR; }\n';
                }
                if (vget !== '')
                    ifpre += ind + vget;

                //var voao = afnam+'_value';
                //ifpre += ind+'Jsi_Value *'+voao+' = Jsi_ValueArrayIndex(interp, args, '+i+');\n';
                    
                if (!isObjNew && i === last && afnam === 'options' && tvlst.indexOf('object')>=0) {
                    var idre, isconfcmd = ((idre=fname.match(/^([a-zA-Z]+)conf$/)) && self.structmap[name+'_'+idre[1]]);
                    var iopnam = name;
                    if (isconfcmd && !fconstr)
                        iopnam += '_'+idre[1];
                    else if (fname !== 'conf' && !fconstr)
                        iopnam += '_'+fname;
                    iopnam +=  self.confSuffix;
                    if (!self.structmap[iopnam])
                        throw('Can not find struct "'+iopnam+'" for cmd '+fname);
                    var iopnamS = iopnam+'_Specs';
                    var iodnam, iott = self.structmap[iopnam];
                    LogTrace('NAM:', iopnamS);
                    if (fname === 'conf') {
                        if (isObj || intData)
                            iodnam = 'cmdPtr';
                        else
                            iodnam = '&'+name+self.varSuffix;
                    } else if (isconfcmd) {
                        // Cmd-local options.
                        iodnam = 'options';
                        ifpre += '  '+iopnam + ' *options = '+name+'_IdGet(cmdPtr, id, 0);\n';
                    } else {
                        // Cmd-local options.
                        iodnam = 'options';
                        ifpostarg += '  '+iopnam + ' data = {}; vr.data = (void*)&data;\n';
                        ifpre += '  '+iopnam + ' *options = ('+iopnam+'*)vrPtr->data;\n';
                        //if (self.structfieldmap[name+'.'+iopnam])
                        //   ifpre += '  *options = cmdPtr->'+self.structfieldmap[name+'.'+iopnam]+';\n';
                    }
                    if (fname === 'conf') {
                        if (i>0) throw("Conf command takes only a single argument");
                        ifpre += '  return Jsi_OptionsConf(interp, (Jsi_OptionSpec*)'+iopnamS+', '+iodnam+', '+voao+', ret, 0);\n';
                    } else if (isconfcmd) {
                        ifpre += '  if (!options || Jsi_OptionsConf(interp, (Jsi_OptionSpec*)'+iopnamS+', '+iodnam+', '+voao+', ret, 0) < 0) return JSI_ERROR;\n';
                    } else {
                        if (!fconstr)
                            ifpre += '  if ('+voao+') { vrPtr->spec = (Jsi_OptionSpec*)'+iopnamS+'; }\n';
                        ifpre += '  if ('+voao+' && Jsi_OptionsProcess(interp, (Jsi_OptionSpec*)'+iopnamS+', '+iodnam+', '+voao+', 0) < 0) return JSI_ERROR;\n';
                    }
                }

            }
            var fcmdNameI =  (isObj && fconstr ? name+'Constructor': fcmdName);
            ffpre += ind+'{ "'+fname+'",\t'+fcmdNameI+',\t'+minargs+','+maxargs+',"'+args+'", .help="'+fhelp
                +'", .retType='+fretType+', .flags='+fflags+', .info='+finfo+', .opts='+fopts+' },\n';
            var ofbody = flnhash;
            for (i of fbody.split('\n')) {
                ipre = i.trim();
                if (ipre.substr(0,6) === 'RETURN') {
                    var retre = ipre.match(/^RETURN\s*\(([a-zA-Z0-9_]*)\);/);
                    if (!retre)
                        throw('return format must be "RETURN(x);" : '+ipre);
                    var coffs = ipre.indexOf('//:');
                    var ctyp;
                    if (coffs<0) {
                        if (rettyp.length!=1)
                            throw("return missing type comment '//:TYPE': "+i);
                        ctyp = rettyp[0];
                    } else {
                        ctyp = ipre.substr(coffs+3).trim();
                    }
                    var rnam = retre[1];
                    var rtyp = typeValidate('return', ctyp);
                    if (rtyp.length!==1)
                        throw("expected single return type");
                    switch (ctyp) {
                        case 'number': i = '{ Jsi_ValueMakeNumber(interp, ret, '+rnam+'); return JSI_OK; }'; break;
                        case 'string': i = '{ Jsi_ValueMakeStringDup(interp, ret, '+rnam+'); return JSI_OK; }'; break;
                        case 'boolean': i = '{ Jsi_ValueMakeBool(interp, ret, '+rnam+'); return JSI_OK; }'; break;
                        case 'null': i = '{ Jsi_ValueMakeNull(interp, ret); return JSI_OK; }'; break;
                        case 'void':
                        case 'undefined': i = 'return JSI_OK;'; break;
                        case 'object': 
                            //if (fname === 'conf')
                            //    i = 'Jsi_OptionsConf(interp, VimyOpts, cmdPtr, Jsi_ValueArrayIndex(interp, args, 0), ret, 0);';
                            i = ''; 
                            break;
                        default: throw("unsupported return type '"+ctyp+"' not one of: number string boolean null undefined"); break;
                    }
                    i = '        '+i;
                }
                ofbody += i + '\n';
            }
            ifpre += ofbody+'\n';
            if (fconstr)
                ifpre += format(self.objCmdStr.replace(/Demo/g, name), self.icode[name+'~'], self.icode[name+'_']);
            if (!isObjNew)
                ifpost += format(self.objOptCmdStr, fcmdName, ifpostarg, fcmdName);
            ifpre += ifpost;
        }
        if (hastilde && !hasconstr)
            throw('defined "function ~" without constructor');
        ffpre += ind+'{ NULL, .help="'+def.label+'" }\n  };\n';
        self.cmddef += '\n' + ifpre + ffpre;
        if (!isObj)
            self.pre += '\n#define JSI_CDATA_HAS_COMMANDS\n';

        if (intData)
            self.cmddefs += '#ifdef JSI_INI_DEFN_'+otyp+'\n  '+otyp+' *cmdPtr = ('+otyp+'*) Jsi_Calloc(1, sizeof(*cmdPtr));\n'
                + '  if (!cmdPtr || JSI_OK != Jsi_CDataStructInit(interp, (uchar*)cmdPtr, "'+otyp+'")) return NULL;\n'
                + '  Jsi_InterpSetData(interp, "'+name+'", (void*)cmdPtr,  Jsi_DeleteData);\n#endif\n';
    }
    
    function GenAllItems(items:object)
    {
        for (var i of items.enums) {
            LogTrace("enum:", i);
            GenEnum(i);
        }
        for (i of items.structs) {
            LogTrace("struct:", i);
            GenStruct(i);
        }
        for (i of items.types) {
            LogTrace("types:", i);
            GenType(i);
        }
        for (i of items.vars) {
            LogTrace("var:", i);
            GenVars(i);
        }
        if (items.cmds.length>1)
            throw("Only one extension can be defined");
        for (i of items.cmds) {
            LogTrace("cmd:", i);
            GenCmd(i);
        }
        return;
    };

    self.jscHeaderStr = '
#ifndef _JSI_CDEFS_Demo_H_
#define _JSI_CDEFS_Demo_H_

#define _GNU_SOURCE
#include <string.h>
#ifdef JSI_CDATA_MAIN
#define JSI_CDATA_IMPL

#ifdef JSI_CDATA_SHARED
#define JSI_USE_STUBS 1
#include "jsi.h"
#else
#if (!defined(CDATA_MULTI_INC) || defined(CDATA_JSI_C_MAIN_Demo))
#include "jsi.c"
#else
#include "jsi.h"
#define JSI_CDATA_SHARED 2
#endif
#endif
#endif
';

    function CDataFinalize () {
        var name = self.name;
        var scnm = self.icode[name+'_'];
        if (!scnm) scnm = '';
        self.out = self.preface + ' ' + self.verStr + ' from: '+self.infile+'\n\n'
            + '#define JSI_EXT_OPTS cmdPtr->popts \n'
            + self.jscHeaderStr.replace(/Demo/g, name) + self.outcode
        /*+ "#ifndef _JSI_CDEFS_"+name+"_H_\n"
        + "#define _JSI_CDEFS_"+name+"_H_\n\n"
        + '#define _GNU_SOURCE\n#include <string.h>\n#ifdef JSI_CDATA_MAIN\n#define JSI_CDATA_IMPL\n\n'
        + '#ifdef JSI_CDATA_SHARED\n#define JSI_USE_STUBS 1\n#include "jsi.h"\n#else\n#include "jsi.c"\n#endif\n#endif\n\n' */
        + self.pre0 + '\n' + self.pre + "\n#ifdef JSI_CDATA_IMPL\n\nJSI_EXTENSION_INI\n#undef JSI_EXTENSION_INI\n#define JSI_EXTENSION_INI\n"
        + self.out0 + self.out + self.out1
        + self.pre1 + '\n' + self.iout
        + "\n  static Jsi_EnumSpec CS_ENUMS_"+name+"[] = {\n"
        + self.enums 
        + "    {}\n  };\n"
        + "\n  static Jsi_StructSpec CS_STRUCTS_"+name+"[] = {\n"
        + self.structs 
        + "    {}\n  };\n"
        + "\n  static Jsi_OptionTypedef CS_TYPES_"+name+"[] = {\n"
        + self.types 
        + "    {}\n  };\n"
        + "\n   static Jsi_VarSpec CS_VARS_"+name+"[] = {\n"
        + self.vardefs 
        + "    {}\n  };\n\n"
        
        + "  static Jsi_CData_Static CS_STATICS_"+name+" = { .name=\""+name+"\", .structs=CS_STRUCTS_"+name
        +", .enums=CS_ENUMS_"+name
        +', .vars=CS_VARS_'+name
        +", .types=CS_TYPES_"+name
        +"  };\n\n"

        + self.cmddef

        
        + "\n\nstatic const Jsi_CData_Static* jsi_c_init_"+name+"(Jsi_Interp *interp) {\n"
        + '  if (interp && (Jsi_PkgRequire(interp, "Cdata", 0)<0 || \n'
        + "      JSI_OK != Jsi_CDataRegister(interp, &CS_STATICS_"+name+"))) return NULL;\n\n"

        + self.cmddefs 

        + "\n  return &CS_STATICS_"+name+";\n}\n\n"
        + "\n#endif\n#endif\n"
        + format(self.selfSuffix.replace(/Demo/g, name), scnm);
        if (self.outFile) {
            if (File.exists(self.outFile)) {
                var ofpre = File.read(self.outFile),
                    ofpp1 = self.preface;
                if (ofpre && ofpre.substr(0, ofpp1.length) != ofpp1)
                    throw('can not overwrite non-generated file: '+self.outFile);
            }
            File.write(self.outFile, self.out);
        } else
            return(self.out);
    }
    
    function StrGetEnum(str:string, lnum:number) {
        LogTrace("DO:", str);
        var top = -1;
        var flds = [];
        var ina = str.match(/^([a-zA-Z0-9_]+)\s+([a-zA-Z0-9_]+)\s*=\s*\{/);
        if (!ina)
            throw("bad def: " + str);
        var name = ina[2];
        var def = {name:name, type:ina[1], lnum:lnum};
        var vli;
        var l = str.trim().split('\n'), li;
        if ((li=l[0].indexOf('//'))>0) {
            label = l[0].substr(li+2).trim();
            def.label = label;
        }
        l = l.splice(1, l.length-2);
        var lastv = -1;
        for (var i in l) {
            //var res = {};
            var s, label = '', v = l[i].trim();
            LogTrace("v:", v);
            vli = v.indexOf('//');
            var reslabel;
            if (vli>0) {
                reslabel = v.substr(vli+2);
                v = v.substr(0,vli).trim();
            }
            if (v === '') continue;
            var vv = v.split(',');
            if (vv.length>1 && vli>0 && vv[1].trim() !== '')
                throw("commented item must be on single line: "+v);
            var vcnt = 0;
            for (var j in vv) {
                vcnt++;
                var vt = vv[j].trim();
                var nval;
                if (vt === '') continue;
                flds[++top] = {};
                if (vcnt == vv.length && reslabel)
                    flds[top].label = reslabel;
                if (vt.indexOf('=')<=0) {
                    flds[top].name = vt;
                    lastv = nval = lastv+1;
                } else {
                    s = vt.match(/^\s*([a-zA-Z0-9_]+)\s*=\s*([^\s]+)\s*$/);
                    LogTrace('s:',s);
                    if (s === null || s.length != 3)
                        throw("invalid: "+vt);
                    flds[top].name = s[1];
                    lastv = nval = parseInt(s[2]);
                }
                flds[top].value = nval;
            }
        }
        LogTrace("AAAA:", top, flds);
        def.flds = flds;
        self.enumIni[name] = flds[0].name;
        return def;
    };

    function StrGetCode(str:string, lnum:number) {
        LogTrace("DO:", str);
        var stp = str.indexOf('{');
        if (stp>=0)
            str = str.substr(stp+1, str.length-stp-3);
        var flnhash = HashLine(lnum, str);
        self.outcode += flnhash+str+'\n';
    };

    self.parmFlags = ("isSpecified,IO,RO,noDupValue,noClear,pass2,dbDirty,dbIgnore,dbRowid,"
        +"nocase,forceInt,bitsetBool,dateOnly,timeOnly,isBits,fmtString,fmtNumber,fmtTime,fmtHex,strict,fieldSetup,"
        +"coerce,noSig,enumSpec,enumUnsigned,enumExact").split(',');

    function ParseFlags(rest:string) {
        debugger;
        if (rest.substr(0,1) !== '<')
            return;
        var ext = null, ree = rest.indexOf('>');
        if (ree<0)
            throw("expected end bracket: "+rest);
        debugger;
        var parms = rest.substr(1, ree-1);
        rest = rest.substr(ree+1).trim();
        LogTrace('parms:', parms);
        var pf = self.parmFlags;
        var f = 0;
        for (var o of parms.split(';')) {
            o = o.trim();
            var oi = pf.indexOf(o);
            if (oi<0) {
                if (o.substr(0,5) === 'FUNC(' && o.substr(o.length-1,1) === ')') {
                    ext = o.substr(5, o.length-6);
                    continue;
                } else
                    throw("unknown flag '"+o+"' expected on of: FUNC() ,"+pf.join(', '));
            }
            f |= (1<<oi);
        }
        return [f, rest, ext];
    }

    function StrGetStruct(str:string, lnum:number) {
        LogTrace("DO: "+str);
        var flds = [], fcnt = 0;
        var ina = str.match(/^([a-zA-Z0-9_]+)\s+([a-zA-Z0-9_]+)\s*=\s*\{/);
        if (!ina)
            throw("bad def: " + str);
        var label, def = {name:ina[2], type:ina[1], opts:null, label:null, init:true, lnum:lnum};
        var li, l = str.trim().split('\n');
        if ((li=l[0].indexOf('//'))>0) {
            label = l[0].substr(li+2).trim();
            def.label = label;
        }
        l = l.splice(1, l.length-2);
        var dfn = def.name+'_Specs';
        if (self.structmap[dfn])
            throw("duplicate struct name");
        self.structmap[def.name] = dfn;
        for (var i in l) {
            var res = {label:'', bit:0, bitset:0, asize:0, flags:0, isstr:false, nowarn:false, data:null};
            var v = l[i].trim();
            LogTrace("v:". v);
            if (v.match(/^<.*>$/)) {
                if (def.opts) throw("multiple opts");
                LogTrace("OPTS:", v);
                def.opts = v.substr(1,v.length-2);
                continue;
            }
            if (v === '') continue;
            var spref = v.substr(0,6);
            if (spref !== 'const ') 
                spref = '';
            else
                v = v.substr(6);
            if (flds.length == 0 && v.substr(0,2) === '//') {
                label = v.substr(2).trim();
                if (!def.label)
                    def.label = label;
                else
                    throw("multiline label not allowed: "+v);
                continue;
            }
            var s = v.match(/^\s*(\S+)\s+([^;]+)\s*;\s*(.*)$/);
            LogTrace('SS:', v);
            if (s === null || s.length < 2)
                throw('invalid field: "'+v+'"');
            res.id = spref + s[1];
            var namval = s[2].trim();
            var rest = s[3].trim();
            label = rest;
            if (label !== "") {
                if (label.substr(0,2) !== '//')
                    throw('expected // after definition: '+label);
                label = label.substr(2).trim();
                if (label.substr(0, 7) === 'NOWARN:') {
                    res.nowarn = true;
                    label = label.substr(7).trim();
                }
            }
            var pfi = ParseFlags(label);
            if (pfi) {
                res.flags = pfi[0].toString(16);
                res.data = pfi[2];
                label = pfi[1];
            }
            res.label = label.trim();
            var nam = namval, val = null, nn;
            if (nam.indexOf('=')>=0)
            {
                nn = nam.split('=');
                if (nn.length != 2)
                    throw('expected nam=val: '+nam);
                nam = nn[0];
                val = nn[1].trim();
                if (val === '')
                    val = "{}";
                else if (val.match(/^".*"$/)) {
                    res.isstr = true;
                    val = val.substr(1,val.length-2);
                }
                if (val.trim() === '')
                    val = "{}";
            }
            nam = nam.trim();
            var n;
            res.idx = fcnt++;
            if (nam[nam.length-1] === '@')
            {
                nam = nam.substr(0, nam.length-1);
                res.flags += '|JSI_OPT_BITSET_ENUM';
                res.bitset = 1;
            } else if (nam.indexOf(':')>=0)
            {
                nn = nam.split(':');
                res.bit = parseInt(nn[1]);
                nam = nn[0].trim();
                res.flags += '|JSI_OPT_IS_BITS';
            } else if ((n = nam.indexOf('[')) && nam.substr(-1) == ']') {
                res.asize = nam.substr(n+1, nam.length-n-2);
                nam = nam.substr(0,n);
            }
            if (!nam.match(/^[a-zA-Z0-9_]+$/))
                throw("field name chars must be in [a-zA-Z0-9_] for '"+nam+"' in "+def.name);
            res.name = nam;
            if (val!==null)
                res.init = val;
            LogTrace('res:', res);
            flds.push(res);
        }
        def.flds = flds;
        return def;
    }
    
    function StrGetVars(str:string, lnum:number) {
        LogTrace("DO: "+str);
        var flds = [];
        var ina = str.match(/^([a-zA-Z0-9_]+)\s+([a-zA-Z0-9_]+)\s*=\s*\{/);
        if (!ina)
            throw("bad vars def: " + str);
        var label, def = {name:ina[2], type:ina[1]};
        var l = str.trim().split('\n');
        l = l.splice(1, l.length-2);
        for (var i in l) {
            var res = {label:'', asize:0, opts:'', ismap:false, ktype:null, varParam:'', lnum:lnum};
            var v = l[i].trim();
            LogTrace("v:", v);
            if (v === '') continue;
            if (flds.length == 0 && v.substr(0,2) === '//') {
                label = v.substr(2).trim();
                if (!def.label)
                    def.label = label;
                else
                    throw("multiline label not allowed: "+v);
                continue;
            }
            var s = v.match(/^\s*(\S+)\s+([^;]+)\s*;\s*(.*)$/);
            LogTrace('SS:', v);
            if (s === null || s.length < 2)
                throw('invalid var: "'+v+'"');
            var typ = res.type = s[1];
            var namval = s[2].trim();
            label = s[3];
            if (label !== "") {
                if (label.substr(0,2) !== '//')
                    throw('expected // after definition: '+label);
                label = label.substr(2).trim();
                if ((s=label.match(/^(\{[^\}]+\})\s*(.*)$/))) {
                    label = s[2];
                    res.opts = s[1]; // Options from start of comment.
                }
            }
            res.label = label.trim();
            var nam = namval, val = null, nn;
            nam = nam.trim();
            if ((nn = nam.indexOf('['))>=0 && nam.substr(-1) == ']') {
                res.asize = nam.substr(nn+1, nam.length-nn-2);
                res.varParam = nam.substr(nn, nam.length-nn);
                nam = nam.substr(0,nn);                
            } else if ((nn = nam.indexOf('{'))>=0 && nam.substr(-1) == '}') {
                res.asize = nam.substr(nn+1, nam.length-nn-2);
                res.varParam = nam.substr(nn, nam.length-nn);
                nam = nam.substr(0,nn);
                res.ismap = 1;
            }
            if (1 || res.asize) {
                var ktyp = null, ktind;
                if (res.ismap && (ktind=res.asize.indexOf('@'))>=0) {
                    ktyp = res.asize.substr(ktind+1);
                    res.ktype = ktyp;
                    LogTrace("Pushing spec:", ktyp);
                }
            }

            res.name = nam;
            if (self.varnames.indexOf(nam)>=0)
                throw("duplicate var name: "+nam);
            self.varnames.push(nam);
            if (val!==null)
                res.init = val.trim();
            LogTrace('res:', res);
            flds.push(res);
        }
        def.flds = flds;
        return def;
    }

    function StrGetCmd(str:string, lnum:number) {
        LogTrace("DO:", str);
        var ina = str.match(/^([a-zA-Z0-9_]+)\s+([a-zA-Z0-9_]+)\s*=\s*\{/);
        if (!ina)
            throw("bad cmds def: " + str);
        var preface = '';;
        var label, sdefs=[], def = {name:ina[2], type:ina[1], fnames:[], lnum:lnum};
        var curdef = '', fcnt = 0;
        var l = str.split('\n'), li;
        if ((li=l[0].indexOf('//'))>0) {
            label = l[0].substr(li+2).trim();
            def.label = label;
        }
        l = l.splice(1, l.length-2);
        var nam = def.name, clnofs = -1;

        for (var i of l) {
            clnofs++;
            var ipre = i.trim();
            /*if (curdef == '' && ipre.substr(0,2) === '//') {
                label = ipre.substr(2).trim();
                if (!def.label)
                    def.label = label;
                else
                    throw("multiline label not allowed: "+ipre);
                continue;
            }*/
            var reg;
            if ((reg=ipre.match(/^function\s*(~|[a-zA-Z0-9_]*)/))) {
                fcnt++;
                def.fnames.push(reg[1]);
                if (curdef !== '') {
                    sdefs.push([curdef, clnofs]);
                    curdef = '';
                }
            } else if (curdef === '') {
                if (fcnt === 0) {
                    preface += i + '\n';
                    continue;
                }
                throw("expected function: "+i);
            }
            curdef += i + '\n';
        }
        if (curdef != '') {
            sdefs.push([curdef, clnofs]);
            curdef = '';
        }
        LogTrace("sdefs:", sdefs.join(','));
        def.flds = sdefs;
        def.preface = preface;
        return def;
    }

    function GetIncludeReg(match, file) {
        str = File.read(file);
        return GetInclude(str);
    }
    
    /*function GetInclude(str:string) {
        if (str.indexOf('include')<0)
            return str;
        return str.replace(/^include\s*=\s*([a-zA-Z0-9_.]+)\s*;$/gm, GetIncludeReg);
    }*/
    
    // Gather all the definitions 
    function GetDefs(str) {
        var curdef = '', gdefs = [], slst, cnt = 0, lcnt = 1;
        //str = GetInclude(str);
        slst = str.split('\n');
        for (var i of slst) {
            cnt++;
            var ipre = i.trim().substr(0,2);
            //if (ipre === '//' || ipre == '') { continue; }
            if (i.trimRight() === '};') {
                //if (curdef === '') throw("extraextra end found at line "+cnt);
                curdef += i;
                gdefs.push([curdef.trim(), lcnt+self.lnstart+1]);
                lcnt = cnt;
                curdef = '';
                continue;
            }
            if (curdef.trim() === ''  && i.indexOf('//')<0 && i.indexOf(';')>=0)
                throw("defn can not be all on one line: "+i);
            curdef += i + '\n';
        }
        if (curdef.trim() !== '') throw("extra input found at end");
        return gdefs;
    }
    
    function mainSub() {
        if (typeof args !== 'array' || !args.length)
            throw "expected 1 or more args";
                    
        if (self.cflags) {
            if (self.compile)
                throw('use either compile or cflags, not both');
            return GetCflags(args);
        }
    
        if (self.jsc.length) {
            self.rootname = args[0];
            var ind = self.jsc.replace(/\\n/g, '\n');
            self.indata = 'extension '+self.rootname+' = {\n'+ ind + '\n};\n';
            self.compile = true;
        } else if (args.length)
            self.rootname = File.rootname(File.tail(args[0]));
        if (self.O !== '-') {
            if (self.O.length)
                self.outFile = self.O;
            else if (self.rootname)
                self.outFile = self.rootname+'.c';
        }
        if (!self.name)
            if (self.rootname)
                self.name = self.rootname;
            else
                self.name = 'main';
        if (self.compile)
            self.addflags = args.slice(1).join(' ');
        else if (args.length != 1)
            throw('expected a single file arg');
        var fname = args[0];
        self.infile = fname;
        if (!self.indata.length)
            self.indata = File.read(fname);
        return process(self.indata);
    }
    
    function process(inp) {
        if (inp.substr(0,2) === '#!') {
            self.lnstart++;
            inp = inp.substr(inp.indexOf('\n')+1);
        }
        while (inp.substr(0,2) === '//' || inp.substr(0,1) == '\n') {
            self.lnstart++;
            inp = inp.substr(inp.indexOf('\n')+1);
        }

        var ina = GetDefs(inp);
        //var ina = inp.match(/([a-zA-Z0-9_]+\s+\S+\s*\{[^\}]+\};)/g);
        LogTrace('INA:', ina);
        for (var j of ina) {
            var i = j[0];
            var ln = j[1];
            LogTrace("i:", i);
            var in1 = i.match(/^([a-zA-Z0-9_]+)\s+[a-zA-Z0-9_]+\s*=\s*\{/);
            if (!in1)
                throw("unknown input: "+i);
            var nam = in1[1];
            switch (nam) {
                case 'code':    StrGetCode(i, ln); break;
                case 'enum':    defs.enums.push(StrGetEnum(i, ln)); break;
                case 'struct':  defs.structs.push(StrGetStruct(i, ln)); break;
                //case 'types':    defs.types.push(StrGetTypes(i)); break;
                case 'vars':    defs.vars.push(StrGetVars(i, ln)); break;
                case 'ext': case 'extension':  defs.cmds.push(StrGetCmd(i, ln)); break;
                default: throw("unknown defn ' "+nam+"' expected: output, struct, enum, vars, extension/ext");
            }
        }
        if (self.json)
            return JSON.stringify(defs);
        GenAllItems(defs);
        if (self.eval) {
            puts(EV);
            return EV;
            for (i of EV.enum)
                CEnum.define(i[0], i[1]);
            for (i of EV.struct) {
                puts(i);
                CStruct.define(i[0], i[1]);
            }
            return EV.vars;
        }
        return CDataFinalize();
    }
    
    function main() {
        var rc = mainSub();
        if (!rc) {
            if (self.compile)
                return CompileShared(self.outFile);
            else
                console.printf('Generated %s', self.outFile);
        } else if ('' !== rc)
            return rc;
    }
    
    self.objOptCmdStr = '
static Jsi_RC %s(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr) {
    Jsi_PkgOpts vr = {};
    %s
    Jsi_RC rc = %sSub(interp, args, _this, ret, funcPtr, &vr);
    if (vr.data &&  vr.spec)
        Jsi_OptionsFree(interp, vr.spec, vr.data, 0);
    return rc;
}';
    
    self.objCmdStr = '

// Start of template code for object commands.

static Jsi_CmdSpec DemoCmds[];

static void DemoObjErase(Demo *cmdPtr)
{
    if (!cmdPtr->_interp)
        return;
    Jsi_OptionsFree(cmdPtr->_interp, Demo_Specs, cmdPtr, 0);
    memset(cmdPtr, 0, sizeof(*cmdPtr));;
}

static Jsi_RC DemoObjFree(Jsi_Interp *interp, void *data)
{
    Demo *cmdPtr = (Demo *)data;
    %s /* FREE_OBJ */
    DemoObjErase(cmdPtr);
    Jsi_Free(cmdPtr);
    return JSI_OK;
}

static bool DemoObjIsTrue(void *data)
{
    return 1;
}

static bool DemoObjEqual(void *data1, void *data2)
{
    return (data1 == data2);
}

static Jsi_UserObjReg DemoObjReg = {
    "Demo",
    DemoCmds,
    DemoObjFree,
    DemoObjIsTrue,
    DemoObjEqual
};

#ifndef DemoLastArg
#define DemoLastArg 0
#endif

static Jsi_CmdProcDecl(DemoConstructor)
{
    
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, DemoLastArg);
    
    Demo *cmdPtr = (Demo *)Jsi_Calloc(1, sizeof(*cmdPtr));
    Jsi_CDataStructInit(interp, (uchar*)cmdPtr, "Demo");
#ifdef CDATA_CODE_GLOB_VAR_Demo
    cmdPtr->_ = &Demo_Data;
#endif
#ifdef CDATA_CODE_PER_INTERP_Demo
    cmdPtr->_ = (void *)Jsi_InterpGetData(interp, "Demo_InterpData", NULL);
#endif
    cmdPtr->popts = Jsi_CommandPkgOpts(interp, funcPtr);

    bool hasOpts = (arg != NULL && !Jsi_ValueIsNull(interp,arg));
    if ((hasOpts && Jsi_OptionsProcess(interp, Demo_Specs, cmdPtr, arg, 0) < 0)
        || DemoDemoCmd(interp, args, _this, ret, funcPtr, cmdPtr) != JSI_OK) {
        DemoObjFree(interp, cmdPtr);
        return JSI_ERROR;
    }
    Jsi_LogDebugExt("Starting");
    Jsi_Value *toacc = NULL;
    if (Jsi_FunctionIsConstructor(funcPtr)) {
        toacc = _this;
    } else {
        Jsi_Obj *o = Jsi_ObjNew(interp);
        Jsi_PrototypeObjSet(interp, "Demo", o);
        Jsi_ValueMakeObject(interp, ret, o);
        toacc = *ret;
    }

    Jsi_Obj *fobj = Jsi_ValueGetObj(interp, toacc);
    int objId;
    if ((objId = Jsi_UserObjNew(interp, &DemoObjReg, fobj, cmdPtr))<0) {
        DemoObjFree(interp, cmdPtr);
        Jsi_ValueMakeUndef(interp, ret);
        return JSI_ERROR;
    }
    return JSI_OK;
}

';

    self.selfSuffix = '
#ifdef JSI_CDATA_MAIN

int Jsi_DemoInit(Jsi_Interp *interp)
{
    jsi_c_init_Demo(interp);
    return JSI_OK;
}

Jsi_RC Jsi_DoneDemo(Jsi_Interp *interp)
{
#ifdef CDATA_CONSTRUCTOR
    if (Jsi_UserObjUnregister(interp, &DemoObjReg) != JSI_OK)
        return JSI_ERROR;
#endif
    Jsi_PkgProvide(interp, "Demo", -1, NULL);
    return JSI_OK;
}

Jsi_InitProc Jsi_InitDemo;

Jsi_RC Jsi_InitDemo(Jsi_Interp *interp, int isRelease)
{
    Jsi_RC rc = JSI_OK;
    if (isRelease)
        rc = Jsi_DoneDemo(interp);
    else  {
#if JSI_USE_STUBS
        if (Jsi_StubsInit(interp, JSI_STUBS_STRICT) != JSI_OK)
            return JSI_ERROR;
#endif
        Jsi_DemoInit(interp);
    }
#ifdef CDATA_MODINIT_CHAIN_Demo
    extern int CDATA_MODINIT_CHAIN_Demo(Jsi_Interp *interp, int release);
    if (rc == JSI_OK && CDATA_MODINIT_CHAIN_Demo (interp, isRelease) != JSI_OK) {
        return JSI_ERROR;
    }
#endif
    void *ddPtr = NULL;
#ifdef CDATA_CODE_GLOB_VAR_Demo
    Demo_ *_ = &Demo_Data; ddPtr = (void*)_;
#endif
#ifdef CDATA_CODE_PER_INTERP_Demo
    Demo_ *_;
    if (isRelease)
        _ = (Demo_ *)Jsi_InterpGetData(interp, "Demo_InterpData", NULL);
    else {
        _ = (Demo_ *)Jsi_Calloc(1, sizeof(Demo_));
        Jsi_InterpSetData(interp, "Demo_InterpData", _, Jsi_DeleteData);
    }
    ddPtr = (void*)_;
#endif
    %s /* INIT_DONE */
#ifdef CDATA_CODE_PER_INTERP_Demo
    if (isRelease)
        Jsi_InterpFreeData(interp, "Demo_InterpData");
#endif
    if (!isRelease) {
        Jsi_RC rc;
#if (defined(CDATA_CODE_GLOB_VAR_Demo) || defined(CDATA_CODE_PER_INTERP_Demo))
        Jsi_PkgOpts vr = {};
        vr.spec = Demo__Specs;
        vr.data = ddPtr;
        vr.cmdSpec = DemoCmds;
        if (Demo_PkgInfo) {
            vr.conf.info = Jsi_ValueNew1(interp);
            rc = Jsi_JSONParse(interp, Demo_PkgInfo, &vr.conf.info, 0);
        }
        if (rc == JSI_OK)
            rc = Jsi_PkgProvideEx(interp, "Demo", 1, Jsi_InitDemo, &vr);
        if (vr.conf.info)
            Jsi_DecrRefCount(interp, vr.conf.info);
#else
        rc = Jsi_PkgProvideEx(interp, "Demo", 1, Jsi_InitDemo, NULL);
#endif
        if (rc != JSI_OK)
            return rc;
#ifdef CDATA_CONSTRUCTOR
        Jsi_Hash *wsys;
        if (!(wsys = Jsi_UserObjRegister(interp, &DemoObjReg))) {
            Jsi_LogBug("Can not init Demo");
            return JSI_ERROR;
        }
        if (!Jsi_CommandCreateSpecs(interp, "Demo", DemoCmds, wsys, JSI_CMDSPEC_ISOBJ))
            return JSI_ERROR;
#else
#ifdef JSI_CDATA_HAS_COMMANDS
        if (!Jsi_CommandCreateSpecs(interp, "Demo", DemoCmds, NULL, 0))
            return JSI_ERROR;
#endif
#endif
    }
    ddPtr = ddPtr;
    return rc;
}


#ifndef JSI_CDATA_SHARED
int main(int argc, char *argv[])
{
    Jsi_InterpOpts opts = {.argc=argc, .argv=argv};
    Jsi_Interp *interp = Jsi_InterpNew(&opts);
    if (Jsi_InitDemo(interp, 0) != JSI_OK)
        return 1;
    Jsi_Main(&opts);
    return(0);
}
#endif
#endif
#undef JSI_EXT_OPTS
';

    var retval = main();
    if (retval === undefined)
        return '';
    return retval;
}

provide(Cdata, "2");
moduleRun(Cdata);

